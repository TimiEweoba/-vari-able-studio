For input validation
If you want to implement input validation... you'll need to install express-validator,
you will need to define the rules, validateResult, and use them in routes,
to do this, create a middleware folder and put validate.js for the validateResult,
then create a validations folder and put userValidation.js for rule definitions,
then after coding, import the 2 files into the routes and apply them....

For confirm password
If you wanna implement this, in your schema use a virtual field, e.g userSchema.virtual('confirmPassword')
Note, If you do it this way you have to go back to your controller and exclude confirmPassword, so it won't be added by mistake to your normal database... You use object destructuting and add confirmPassword then , ...userData, and assign it to req.body. userData will keep the other fields, but confirmPassword will be excluded. Also use userData instead of req.body below when you create a new user.
Then in your validation rule file, add it there with a custom rule that checks if the password is the same with confirmPassword. Custom rule takes 2 parameters, value and {req}.
Lastly make sure your password is stronger, you can do that in the validation rule file as well.

For Hashing and Salting with bcrypt
Install bcryptjs, then go to your model to import with name bcrypt, from bcryptjs... Then befor before mongoose.model, add a mongoose middleware hook, userSchema.pre('save', async function code for bcrypt, put next as parameter), in the function, check for modification first, then generate the salt and hash the password with salt and next.

For authentication, (register and login)
create 2 files, authController.js to put the logic of register and login, then authRoutes.js were you will assign them to routes. Import jswonwebtoken and bcryptjs. 

Create a register async function (exported) and follow the steps;
1. Define req.body but exclude confirmPassword as usual cos it's virtual
2. Confirm password check (no need for this cos we already used express-validation, so skip this)
3. Check if users exists using email then retun a response
4. Create the user and save
5. Generate JWT, then after send a response with token (jwt.sign() will take 3 parameters; the payload which is the id and role~basically the data, the jwt secret key in your .env, and options like expiresIn)
6. put everything in a try catch block
7. Then go to your authRoutes.js, import all necessary stuff, and add the register route, also put validations for creating a user and the overall validate.

Create a login async function (exported) and follow the steps;
1. Define req.body with just email and password only this time
2. Check if email exists the same way you did for users in register
3. compare password with hashed password using bcrypt.compare
4. Generate JWT, then after send a response with token (jwt.sign() will take 3 parameters; the payload which is the id and role~basically the data, the jwt secret key in your .env, and options like expiresIn)
5. put everything in a try catch block
6. Then go to your authRoutes.js, import all necessary stuff, and add the login route, also put validations, overall validate.

SO BASICALLY AUTHENTICATION ISN'T DONE YET.
The validation middlewarejust validates input, but we still need another middleware to verify identity, by verifying a valid JWT token before letting the user access the route. Protecting it from unauthorized access.

(Take note; 
Bearer is an authentication scheme - it literally means "whoever holds this token can access the resources
Headers are like envelope information - they contain metadata about the HTTP request/response, not the actual data.
)

So, JWT authentication middleware;


